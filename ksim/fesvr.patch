diff --git a/ksim/emulator.cpp b/ksim/emulator.cpp
index 01abb1d..64be225 100644
--- a/ksim/emulator.cpp
+++ b/ksim/emulator.cpp
@@ -2,19 +2,206 @@
 #include<cstdlib>
 #include<chrono>
 #include<iostream>
+#include <fesvr/dtm.h>
+#include <getopt.h>
+#include <unistd.h>
+
+dtm_t* dtm;
+
+void tick_dtm() {
+    dtm_t::resp resp_bits;
+    resp_bits.resp = SimDTM_debug_resp_bits_resp;
+    resp_bits.data = SimDTM_debug_resp_bits_data;
+
+    dtm->tick(SimDTM_debug_req_ready,
+              SimDTM_debug_resp_valid,
+              resp_bits);
+    SimDTM_debug_resp_ready = dtm->resp_ready();
+    SimDTM_debug_req_valid = dtm->req_valid();
+    SimDTM_debug_req_bits_addr = dtm->req_bits().addr;
+    SimDTM_debug_req_bits_op = dtm->req_bits().op;
+    SimDTM_debug_req_bits_data = dtm->req_bits().data;
+
+    SimDTM_exit = dtm->done() ? (dtm->exit_code() << 1 | 1) : 0;
+}
+
+static void usage(const char * program_name) {
+  printf("Usage: %s [EMULATOR OPTION]... [VERILOG PLUSARG]... [HOST OPTION]... BINARY [TARGET OPTION]...\n",
+         program_name);
+  fputs("\
+Run a BINARY on the Rocket Chip emulator.\n\
+\n\
+Mandatory arguments to long options are mandatory for short options too.\n\
+\n\
+EMULATOR OPTIONS\n\
+  -c, --cycle-count        Print the cycle count before exiting\n\
+       +cycle-count\n\
+  -h, --help               Display this help and exit\n\
+  -m, --max-cycles=CYCLES  Kill the emulation after CYCLES\n\
+       +max-cycles=CYCLES\n\
+  -s, --seed=SEED          Use random number seed SEED\n\
+  -V, --verbose            Enable all Chisel printfs (cycle-by-cycle info)\n\
+       +verbose\n\
+", stdout);
+  fputs("\
+  -v, --vcd=FILE,          Write vcd trace to FILE (or '-' for stdout)\n\
+  -x, --dump-start=CYCLE   Start VCD tracing at CYCLE\n\
+       +dump-start\n\
+", stdout);
+  // fputs("\n" PLUSARG_USAGE_OPTIONS, stdout);
+  fputs("\n" HTIF_USAGE_OPTIONS, stdout);
+  printf("\n"
+"EXAMPLES\n"
+"  - run a bare metal test:\n"
+"    %s $RISCV/riscv64-unknown-elf/share/riscv-tests/isa/rv64ui-p-add\n"
+"  - run a bare metal test showing cycle-by-cycle information:\n"
+"    %s +verbose $RISCV/riscv64-unknown-elf/share/riscv-tests/isa/rv64ui-p-add 2>&1 | spike-dasm\n"
+"  - run an ELF (you wrote, called 'hello') using the proxy kernel:\n"
+"    %s pk hello\n",
+         program_name, program_name, program_name);
+}
 
 int main(int argc, char ** argv) {
+  unsigned random_seed = (unsigned)time(NULL) ^ (unsigned)getpid();
+  bool verbose = false;
+  uint64_t max_cycles = -1;
+  int ret = 0;
+  bool print_cycles = false;
+  char ** htif_argv = NULL;
+  int verilog_plusargs_legal = 1;
+
+  while (1) {
+    static struct option long_options[] = {
+      {"cycle-count", no_argument,       0, 'c' },
+      {"help",        no_argument,       0, 'h' },
+      {"max-cycles",  required_argument, 0, 'm' },
+      {"seed",        required_argument, 0, 's' },
+      {"verbose",     no_argument,       0, 'V' },
+      HTIF_LONG_OPTIONS
+    };
+    int option_index = 0;
+    int c = getopt_long(argc, argv, "-chm:s:V", long_options, &option_index);
+    if (c == -1) break;
+ retry:
+    switch (c) {
+      // Process long and short EMULATOR options
+      case '?': usage(argv[0]);             return 1;
+      case 'c': print_cycles = true;        break;
+      case 'h': usage(argv[0]);             return 0;
+      case 'm': max_cycles = atoll(optarg); break;
+      case 's': random_seed = atoi(optarg); break;
+      case 'V': verbose = true;             break;
+#if VM_TRACE
+      case 'v': {
+        vcdfile = strcmp(optarg, "-") == 0 ? stdout : fopen(optarg, "w");
+        if (!vcdfile) {
+          std::cerr << "Unable to open " << optarg << " for VCD write\n";
+          return 1;
+        }
+        break;
+      }
+      case 'x': start = atoll(optarg);      break;
+#endif
+      // Process legacy '+' EMULATOR arguments by replacing them with
+      // their getopt equivalents
+      case 1: {
+        std::string arg = optarg;
+        if (arg.substr(0, 1) != "+") {
+          optind--;
+          goto done_processing;
+        }
+        if (arg == "+verbose")
+          c = 'V';
+        else if (arg.substr(0, 12) == "+max-cycles=") {
+          c = 'm';
+          optarg = optarg+12;
+        }
+        else if (arg.substr(0, 12) == "+cycle-count")
+          c = 'c';
+        // If we don't find a legacy '+' EMULATOR argument, it still could be
+        // a VERILOG_PLUSARG and not an error.
+        // else if (verilog_plusargs_legal) {
+        //   const char ** plusarg = &verilog_plusargs[0];
+        //   int legal_verilog_plusarg = 0;
+        //   while (*plusarg && (legal_verilog_plusarg == 0)){
+        //     if (arg.substr(1, strlen(*plusarg)) == *plusarg) {
+        //       legal_verilog_plusarg = 1;
+        //     }
+        //     plusarg ++;
+        //   }
+        //   if (!legal_verilog_plusarg) {
+        //     verilog_plusargs_legal = 0;
+        //   } else {
+        //     c = 'P';
+        //   }
+        //   goto retry;
+        // }
+        // If we STILL don't find a legacy '+' argument, it still could be
+        // an HTIF (HOST) argument and not an error. If this is the case, then
+        // we're done processing EMULATOR and VERILOG arguments.
+        else {
+          static struct option htif_long_options [] = { HTIF_LONG_OPTIONS };
+          struct option * htif_option = &htif_long_options[0];
+          while (htif_option->name) {
+            if (arg.substr(1, strlen(htif_option->name)) == htif_option->name) {
+              optind--;
+              goto done_processing;
+            }
+            htif_option++;
+          }
+          std::cerr << argv[0] << ": invalid plus-arg (Verilog or HTIF) \""
+                    << arg << "\"\n";
+          c = '?';
+        }
+        goto retry;
+      }
+      case 'P': break; // Nothing to do here, Verilog PlusArg
+      // Realize that we've hit HTIF (HOST) arguments or error out
+      default:
+        if (c >= HTIF_LONG_OPTIONS_OPTIND) {
+          optind--;
+          goto done_processing;
+        }
+        c = '?';
+        goto retry;
+    }
+  }
+
+done_processing:
+  if (optind == argc) {
+    std::cerr << "No binary specified for emulator\n";
+    usage(argv[0]);
+    return 1;
+  }
+  int htif_argc = 1 + argc - optind;
+  htif_argv = (char **) malloc((htif_argc) * sizeof (char *));
+  htif_argv[0] = argv[0];
+  for (int i = 1; optind < argc;) htif_argv[i++] = argv[optind++];
+
+  if (verbose)
+    fprintf(stderr, "using random seed %u\n", random_seed);
+
+  srand(random_seed);
+  srand48(random_seed);
+  dtm = new dtm_t(htif_argc, htif_argv);
   int cnt = atoi(argv[1]);
-  SimDTM_debug_req_valid = 1;
-  SimDTM_debug_resp_valid = 1;
+  SimDTM_debug_req_valid = 0;
+  SimDTM_debug_resp_valid = 0;
+  SimDTM_exit = 0;
   reset = 1;
   for(auto i = TestHarness_reset_ahead; i >= 0; i--) {
     TestHarness();
-    reset = 0;
   }
+  size_t trace_count = 0;
   auto start = std::chrono::system_clock::now();
-  for(auto i = 0; i < cnt; i++) {
+  reset = 0;
+  while(trace_count < max_cycles) {
+    if (dtm->done() || io_success) {
+      break;
+    }
     TestHarness();
+    tick_dtm();
+    trace_count++;
   }
   auto stop = std::chrono::system_clock::now();
   std::cout << std::chrono::duration_cast<std::chrono::microseconds>(stop - start).count() << std::endl;
